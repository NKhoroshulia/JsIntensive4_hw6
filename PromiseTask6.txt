Ситуация №1:
1.  button.addEventListener('click', () => {
2.    Promise.resolve().then(() => console.log('Microtask 1'));
3.    console.log('Listener 1');
4.  });
5.  
6.  button.addEventListener('click', () => {
7.    Promise.resolve().then(() => console.log('Microtask 2'));
8.    console.log('Listener 2');
9.  });

Вопрос: в каком порядке будут выведены в консоль сообщения, когда пользователь кликнет по кнопке button?

В данном примере при нажатии на кнопку, порядок вывода будет таким: Listener 1, Microtask 1, Listener 2, Microtask 2. 
У нас есть 2 обработчика на одно событие, сначала у нас отработает первый, где сперва идет выполнение синхронного кода: console.log('Listener 1'), 
после него только идет выполнение асинхроннного кода Promise.resolve().then(() => console.log('Microtask 1')) (как только стек освобождается). 
И поскольку у нас 2 обработчика, выполнение будет идти один за одним в порядке очереди.



Ситуация №2:
1.    button.addEventListener('click', () => {
2.      Promise.resolve().then(() => console.log('Microtask 1'));
3.      console.log('Listener 1');
4.    });
5.    
6.    button.addEventListener('click', () => {
7.      Promise.resolve().then(() => console.log('Microtask 2'));
8.      console.log('Listener 2');
9.    });
10.  
11. button.click(); 

В данном примере мы вызываем события в ручную/с помощью кода (как правильней...). Вывод будет такой Listener1, Listener2, Microtask1, Microtask2. 
Получается что весь наш скрипт находится в стеке, и выполнение нашего кода происходит синхронно, сначала выведет listener1, 
и по скольку в наш стек еще не пуст мы не может перейти к выводу Microstak1, мы сначала выполняем 
console.log('Listener 2'), а затем возвращаемся к выполненинию then(() => console.log('Microtask 1')) и then(() => console.log('Microtask 2'));

Я понимаю так, что разница в том, что в первом примере идет вызов событий последоваетльно, 
то есть в стек выполнения сначала попадает первый обработчик событй, а после завершения его выполнения, приступает к выполнению второго обработчика.
А во втором примере из-за того что мы его вызываем прямо в коде, в наш стек одномвременно попадает сразу два обработчика, 
ну и там сначала он выполняет синхронные операции,  а после них приступает к выполнению асинхронных.

